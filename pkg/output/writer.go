package output

import (
	"encoding/csv"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/thechosenone-shall-prevail/KERB-SLEUTH/pkg/krb"
	"gopkg.in/yaml.v3"
)

type Results struct {
	Summary    Summary         `json:"summary"`
	Candidates []krb.Candidate `json:"candidates"`
}

type Summary struct {
	TotalUsers           int `json:"total_users"`
	ASREPCandidates      int `json:"asrep_candidates"`
	KerberoastCandidates int `json:"kerberoast_candidates"`
}

func WriteJSON(path string, results Results) error {
	// Ensure directory exists
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return err
	}

	data, err := json.MarshalIndent(results, "", "  ")
	if err != nil {
		return err
	}

	return os.WriteFile(path, data, 0644)
}

func WriteCSV(path string, results Results) error {
	file, err := os.Create(path)
	if err != nil {
		return err
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	// Write header
	header := []string{"SamAccountName", "Type", "Score", "Severity", "Reasons", "SPNs", "ExportHashPath"}
	if err := writer.Write(header); err != nil {
		return err
	}

	// Write candidates
	for _, candidate := range results.Candidates {
		severity := extractSeverity(candidate.Reasons)
		reasons := strings.Join(candidate.Reasons, "; ")
		spns := strings.Join(candidate.SPNs, "; ")

		record := []string{
			candidate.SamAccountName,
			candidate.Type,
			fmt.Sprintf("%d", candidate.Score),
			severity,
			reasons,
			spns,
			candidate.ExportHashPath,
		}

		if err := writer.Write(record); err != nil {
			return err
		}
	}

	return nil
}

func WriteHashExport(basePath string, results Results) error {
	// Create hashes directory
	hashDir := "hashes"
	if err := os.MkdirAll(hashDir, 0755); err != nil {
		return err
	}

	// Separate AS-REP and Kerberoast hashes
	var asrepHashes []string
	var kerberoastHashes []string

	for _, candidate := range results.Candidates {
		if candidate.Hash != "" {
			switch candidate.Type {
			case "ASREP":
				asrepHashes = append(asrepHashes, candidate.Hash)
			case "KERBEROAST":
				kerberoastHashes = append(kerberoastHashes, candidate.Hash)
			}
		}
	}

	// Write AS-REP hashes
	if len(asrepHashes) > 0 {
		asrepFile := filepath.Join(hashDir, "asrep_hashes.txt")
		if err := writeHashFile(asrepFile, asrepHashes, "AS-REP Roasting"); err != nil {
			return fmt.Errorf("failed to write AS-REP hashes: %v", err)
		}
		log.Printf("ðŸ“„ Exported %d AS-REP hashes to %s", len(asrepHashes), asrepFile)
	}

	// Write Kerberoast hashes
	if len(kerberoastHashes) > 0 {
		kerbFile := filepath.Join(hashDir, "kerberoast_hashes.txt")
		if err := writeHashFile(kerbFile, kerberoastHashes, "Kerberoasting"); err != nil {
			return fmt.Errorf("failed to write Kerberoast hashes: %v", err)
		}
		log.Printf("ðŸ“„ Exported %d Kerberoast hashes to %s", len(kerberoastHashes), kerbFile)
	}

	// Write cracking instructions
	if len(asrepHashes) > 0 || len(kerberoastHashes) > 0 {
		readmePath := filepath.Join(hashDir, "CRACKING_GUIDE.txt")
		if err := writeCrackingGuide(readmePath, len(asrepHashes), len(kerberoastHashes)); err != nil {
			return fmt.Errorf("failed to write cracking guide: %v", err)
		}
	}

	return nil
}

// writeHashFile writes hashes to a file with proper formatting
func writeHashFile(filePath string, hashes []string, attackType string) error {
	file, err := os.Create(filePath)
	if err != nil {
		return err
	}
	defer file.Close()

	// Write header
	fmt.Fprintf(file, "# %s Hash Export\n", attackType)
	fmt.Fprintf(file, "# Generated by KERB-SLEUTH v1.0.0\n")
	fmt.Fprintf(file, "# WARNING: For authorized security testing only!\n")
	fmt.Fprintf(file, "# Total hashes: %d\n", len(hashes))
	fmt.Fprintf(file, "#\n")

	// Write hashes
	for _, hash := range hashes {
		fmt.Fprintln(file, hash)
	}

	return nil
}

// writeCrackingGuide creates a guide for hash cracking
func writeCrackingGuide(filePath string, asrepCount, kerbCount int) error {
	file, err := os.Create(filePath)
	if err != nil {
		return err
	}
	defer file.Close()

	guide := fmt.Sprintf(`KERBEROS HASH CRACKING GUIDE
============================
Generated by KERB-SLEUTH v1.0.0

HASH SUMMARY:
- AS-REP hashes: %d (in asrep_hashes.txt)
- Kerberoast hashes: %d (in kerberoast_hashes.txt)

HASHCAT COMMANDS:
================

AS-REP Roasting (mode 18200):
hashcat -m 18200 asrep_hashes.txt /usr/share/wordlists/rockyou.txt -o cracked_asrep.pot

Kerberoasting (mode 13100):
hashcat -m 13100 kerberoast_hashes.txt /usr/share/wordlists/rockyou.txt -o cracked_kerberoast.pot

JOHN THE RIPPER COMMANDS:
========================

AS-REP Roasting:
john --format=krb5asrep asrep_hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt

Kerberoasting:
john --format=krb5tgs kerberoast_hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt

ADDITIONAL OPTIONS:
==================

# Use GPU acceleration (if available)
hashcat -m 18200 asrep_hashes.txt rockyou.txt -O -w 3

# Use custom wordlist
hashcat -m 13100 kerberoast_hashes.txt /path/to/custom/wordlist.txt

# Show cracked passwords
hashcat -m 18200 asrep_hashes.txt --show
john --format=krb5asrep asrep_hashes.txt --show

WARNING: Only use these commands on systems you own or have explicit 
written permission to test. Unauthorized access is illegal!
`, asrepCount, kerbCount)

	_, err = file.WriteString(guide)
	return err
}

func WriteSigmaRules(path string, results Results) error {
	rules := []map[string]interface{}{
		{
			"title":       "AS-REP Roasting Detection",
			"description": "Detects potential AS-REP roasting attempts",
			"status":      "experimental",
			"logsource": map[string]string{
				"product": "windows",
				"service": "security",
			},
			"detection": map[string]interface{}{
				"selection": map[string]interface{}{
					"EventID":     4768,
					"PreAuthType": 0,
				},
				"condition": "selection",
			},
			"level": "high",
		},
		{
			"title":       "Kerberoasting Detection",
			"description": "Detects potential Kerberoasting attempts",
			"status":      "experimental",
			"logsource": map[string]string{
				"product": "windows",
				"service": "security",
			},
			"detection": map[string]interface{}{
				"selection": map[string]interface{}{
					"EventID":       4769,
					"ServiceName":   "*$",
					"TicketOptions": "0x40810000",
				},
				"condition": "selection",
			},
			"level": "high",
		},
	}

	data, err := yaml.Marshal(rules)
	if err != nil {
		return err
	}

	return os.WriteFile(path, data, 0644)
}

func extractSeverity(reasons []string) string {
	for _, reason := range reasons {
		if strings.Contains(reason, "Severity:") {
			parts := strings.Split(reason, ":")
			if len(parts) >= 2 {
				return strings.TrimSpace(parts[1])
			}
		}
	}
	return "Unknown"
}
