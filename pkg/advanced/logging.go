package advanced

import (
	"encoding/json"
	"fmt"
	"os"
	"time"
)

// LoggingResult represents logging and detection analysis results
type LoggingResult struct {
	EventType      string
	SourceIP       string
	Username       string
	Domain         string
	Timestamp      time.Time
	EncryptionType int
	SPN            string
	RiskLevel      string
	IOCs           []string
	DetectionRules []string
}

// LoggingAnalyzer handles logging and detection analysis
type LoggingAnalyzer struct {
	Results []*LoggingResult
}

// NewLoggingAnalyzer creates a new logging analyzer
func NewLoggingAnalyzer() *LoggingAnalyzer {
	return &LoggingAnalyzer{
		Results: []*LoggingResult{},
	}
}

// LogKDCRequest logs KDC request events
func (la *LoggingAnalyzer) LogKDCRequest(eventType, sourceIP, username, domain string, encType int) *LoggingResult {
	result := &LoggingResult{
		EventType:      eventType,
		SourceIP:       sourceIP,
		Username:       username,
		Domain:         domain,
		Timestamp:      time.Now(),
		EncryptionType: encType,
		IOCs:           []string{},
		DetectionRules: []string{},
	}

	// Analyze for suspicious patterns
	la.analyzeSuspiciousPatterns(result)

	la.Results = append(la.Results, result)
	return result
}

// LogS4UEvent logs S4U delegation events
func (la *LoggingAnalyzer) LogS4UEvent(sourceIP, username, targetService string) *LoggingResult {
	result := &LoggingResult{
		EventType:      "S4U2Proxy",
		SourceIP:       sourceIP,
		Username:       username,
		Timestamp:      time.Now(),
		SPN:            targetService,
		IOCs:           []string{},
		DetectionRules: []string{},
	}

	result.IOCs = append(result.IOCs, fmt.Sprintf("S4U2Proxy request from %s to %s", username, targetService))
	result.DetectionRules = append(result.DetectionRules, "S4U2Proxy delegation detected")

	la.Results = append(la.Results, result)
	return result
}

// GenerateSigmaRules generates Sigma detection rules
func (la *LoggingAnalyzer) GenerateSigmaRules() []map[string]interface{} {
	rules := []map[string]interface{}{
		{
			"title":       "AS-REP Roasting Detection",
			"description": "Detects potential AS-REP roasting attempts",
			"status":      "experimental",
			"logsource": map[string]string{
				"product": "windows",
				"service": "security",
			},
			"detection": map[string]interface{}{
				"selection": map[string]interface{}{
					"EventID":     4768,
					"PreAuthType": 0,
				},
				"condition": "selection",
			},
			"level": "high",
		},
		{
			"title":       "Kerberoasting Detection",
			"description": "Detects potential Kerberoasting attempts",
			"status":      "experimental",
			"logsource": map[string]string{
				"product": "windows",
				"service": "security",
			},
			"detection": map[string]interface{}{
				"selection": map[string]interface{}{
					"EventID":       4769,
					"ServiceName":   "*$",
					"TicketOptions": "0x40810000",
				},
				"condition": "selection",
			},
			"level": "high",
		},
		{
			"title":       "S4U2Proxy Delegation Detection",
			"description": "Detects S4U2Proxy delegation events",
			"status":      "experimental",
			"logsource": map[string]string{
				"product": "windows",
				"service": "security",
			},
			"detection": map[string]interface{}{
				"selection": map[string]interface{}{
					"EventID":       4769,
					"TicketOptions": "0x40810000",
				},
				"condition": "selection",
			},
			"level": "medium",
		},
	}

	return rules
}

// ExportSplunkFormat exports data in Splunk HEC format
func (la *LoggingAnalyzer) ExportSplunkFormat(outputFile string) error {
	file, err := os.Create(outputFile)
	if err != nil {
		return err
	}
	defer file.Close()

	for _, result := range la.Results {
		splunkEvent := map[string]interface{}{
			"time":       result.Timestamp.Unix(),
			"host":       "kerb-sleuth",
			"source":     "kerb-sleuth",
			"sourcetype": "kerberos_security",
			"event":      result,
		}

		data, _ := json.Marshal(splunkEvent)
		fmt.Fprintln(file, string(data))
	}

	return nil
}

// ExportIOCs exports Indicators of Compromise
func (la *LoggingAnalyzer) ExportIOCs(outputFile string) error {
	file, err := os.Create(outputFile)
	if err != nil {
		return err
	}
	defer file.Close()

	fmt.Fprintf(file, "# Kerberos Security IOCs\n")
	fmt.Fprintf(file, "# Generated by KERB-SLEUTH Advanced Module\n")
	fmt.Fprintf(file, "# Timestamp: %s\n\n", time.Now().Format(time.RFC3339))

	for _, result := range la.Results {
		if len(result.IOCs) > 0 {
			fmt.Fprintf(file, "## Event: %s\n", result.EventType)
			fmt.Fprintf(file, "Timestamp: %s\n", result.Timestamp.Format(time.RFC3339))
			fmt.Fprintf(file, "Source IP: %s\n", result.SourceIP)
			fmt.Fprintf(file, "Username: %s\n", result.Username)
			fmt.Fprintf(file, "IOCs:\n")
			for _, ioc := range result.IOCs {
				fmt.Fprintf(file, "  - %s\n", ioc)
			}
			fmt.Fprintf(file, "\n")
		}
	}

	return nil
}

// Helper functions
func (la *LoggingAnalyzer) analyzeSuspiciousPatterns(result *LoggingResult) {
	// Check for unusual encryption types
	if result.EncryptionType != 23 && result.EncryptionType != 18 {
		result.IOCs = append(result.IOCs, fmt.Sprintf("Unusual encryption type: %d", result.EncryptionType))
		result.RiskLevel = "Medium"
	}

	// Check for repeated requests (simplified)
	requestCount := 0
	for _, r := range la.Results {
		if r.SourceIP == result.SourceIP && r.Username == result.Username {
			requestCount++
		}
	}

	if requestCount > 10 {
		result.IOCs = append(result.IOCs, fmt.Sprintf("Repeated requests from %s (%d requests)", result.SourceIP, requestCount))
		result.RiskLevel = "High"
	}

	if result.RiskLevel == "" {
		result.RiskLevel = "Low"
	}
}
